# WHTS协议库质量检查清单

## 目的
确保WHTS协议库在交付给团队成员前达到生产质量标准，避免在协作开发中出现问题。

## 使用方法
1. 按照清单逐项检查
2. 确保所有项目都通过验证
3. 在每个通过的项目前打勾 ✅
4. 记录发现的问题并及时修复

---

## 📋 检查清单

### 1. 代码编译验证
- [ ] **无编译错误**: 使用 `g++ -std=c++17 -Wall -Wextra -Werror` 编译通过
- [ ] **无编译警告**: 开启所有警告选项后无警告输出
- [ ] **头文件包含**: 所有必要的头文件都已正确包含
- [ ] **命名空间**: 所有代码都在 `WhtsProtocol` 命名空间内
- [ ] **C++17兼容**: 使用的所有特性都符合C++17标准

**验证命令**: 
```bash
g++ -std=c++17 -Wall -Wextra -Werror -I src src/WhtsProtocol.cpp src/fragmentation_test.cpp -o test
```

### 2. 功能正确性验证
- [ ] **消息序列化**: 所有消息类型能正确序列化和反序列化
- [ ] **帧处理**: 帧的打包和解析功能正常
- [ ] **设备状态**: DeviceStatus 位字段操作正确
- [ ] **包解析**: 所有包类型（Master2Slave、Slave2Master、Slave2Backend）解析正常
- [ ] **错误处理**: 无效数据能被正确识别和处理

**验证方法**: 运行 `protocol_validation.exe`

### 3. 分片功能验证
- [ ] **自动分片**: 大于MTU的帧能自动分片
- [ ] **分片标识**: fragmentsSequence 和 moreFragmentsFlag 设置正确
- [ ] **分片大小**: 每个分片大小不超过设定的MTU
- [ ] **分片重组**: 分片能正确重组为原始帧
- [ ] **乱序处理**: 乱序到达的分片能正确重组
- [ ] **MTU设置**: 支持不同MTU大小的设置

**验证方法**: 运行 `fragmentation_test.exe`

### 4. 粘包处理验证
- [ ] **帧边界识别**: 能正确识别帧头 0xAB 0xCD
- [ ] **多帧分离**: 粘连的多个帧能正确分离
- [ ] **不完整帧**: 不完整的帧会等待更多数据
- [ ] **缓冲区管理**: 接收缓冲区能正确管理
- [ ] **内存保护**: 有防止缓冲区溢出的保护机制

**验证方法**: 运行粘包测试用例

### 5. 边界条件处理
- [ ] **空数据**: 处理空数据不会崩溃
- [ ] **无效帧头**: 无效帧头数据被正确拒绝
- [ ] **数据长度**: 处理各种长度的数据（包括超长数据）
- [ ] **最小/最大MTU**: 极端MTU值能正确处理
- [ ] **内存限制**: 大量数据不会导致内存溢出

**验证方法**: 运行边界条件测试

### 6. 性能要求验证
- [ ] **处理速度**: 1000个小消息处理时间 < 1秒
- [ ] **分片效率**: 10KB数据分片时间 < 100ms
- [ ] **内存使用**: 长时间运行内存使用稳定
- [ ] **CPU占用**: 正常负载下CPU占用合理

**验证方法**: 运行性能测试

### 7. 内存安全验证
- [ ] **无内存泄漏**: 长时间运行无内存泄漏
- [ ] **缓冲区安全**: 不会发生缓冲区溢出
- [ ] **智能指针**: 正确使用智能指针管理资源
- [ ] **异常安全**: 异常情况下资源能正确释放

**验证方法**: 使用 Valgrind 或类似工具检查

### 8. API设计验证
- [ ] **接口一致性**: 所有公开接口设计一致
- [ ] **参数验证**: 对输入参数进行适当验证
- [ ] **返回值**: 返回值含义明确且一致
- [ ] **错误码**: 错误情况有明确的错误码或异常
- [ ] **向后兼容**: 保持与原有接口的兼容性

**验证方法**: 代码审查和接口测试

### 9. 文档完整性
- [ ] **头文件注释**: 所有公开接口都有注释
- [ ] **使用指南**: FRAGMENTATION_GUIDE.md 内容完整准确
- [ ] **示例代码**: 提供可运行的示例代码
- [ ] **API文档**: 接口文档与实际代码一致
- [ ] **更新日志**: 记录了所有重要变更

**验证方法**: 文档审查

### 10. 代码质量
- [ ] **代码风格**: 遵循一致的代码风格
- [ ] **命名规范**: 变量、函数、类命名清晰
- [ ] **函数长度**: 函数长度适中，逻辑清晰
- [ ] **代码复用**: 避免重复代码
- [ ] **常量定义**: 魔法数字都定义为常量

**验证方法**: 代码审查

### 11. 测试覆盖度
- [ ] **单元测试**: 所有核心功能都有对应的单元测试
- [ ] **集成测试**: 组件间交互功能有集成测试
- [ ] **边界测试**: 覆盖各种边界条件
- [ ] **错误测试**: 测试各种错误情况的处理
- [ ] **性能测试**: 包含性能基准测试

**验证方法**: 运行完整测试套件

### 12. 平台兼容性
- [ ] **Windows兼容**: 在Windows平台编译运行正常
- [ ] **Linux兼容**: 在Linux平台编译运行正常
- [ ] **编译器兼容**: 支持主流C++编译器（GCC、Clang、MSVC）
- [ ] **大小端**: 正确处理字节序问题
- [ ] **位宽兼容**: 32位和64位平台都支持

**验证方法**: 多平台编译测试

---

## 🔧 验证工具

### 自动化验证脚本
- **Windows**: `verify_protocol.bat`
- **Linux**: `verify_protocol.sh` (可创建)

### 手动验证命令
```bash
# 编译验证
g++ -std=c++17 -Wall -Wextra -Werror -I src src/WhtsProtocol.cpp src/protocol_validation.cpp -o validation_test

# 运行测试
./validation_test

# 内存检查（Linux）
valgrind --leak-check=full ./validation_test
```

### CMake测试
```bash
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Debug ..
make
ctest --output-on-failure
```

---

## 🚀 交付标准

### 必须通过的项目（零容忍）
- ✅ 无编译错误和警告
- ✅ 所有核心功能测试通过  
- ✅ 无内存泄漏
- ✅ 文档与代码一致

### 建议优化的项目
- 性能达到预期指标
- 代码风格一致性
- 测试覆盖度 > 90%
- 跨平台兼容性

---

## 📝 问题记录模板

发现问题时，请使用以下格式记录：

```
## 问题 #001
**类别**: [编译/功能/性能/文档]
**严重程度**: [Critical/High/Medium/Low]
**描述**: 简述问题
**重现步骤**: 
1. 步骤1
2. 步骤2
**预期行为**: 应该如何表现
**实际行为**: 实际发生了什么
**修复方案**: 如何修复
**验证方法**: 如何验证修复效果
**状态**: [Open/Fixed/Verified]
```

---

## ✅ 最终检查

在交付前，请确认：

- [ ] 所有检查项目都已通过
- [ ] 自动化验证脚本运行成功
- [ ] 生成的可执行文件能正常运行
- [ ] 文档和示例代码都已更新
- [ ] 代码已提交到版本控制系统

**签名**: _________________ **日期**: _________________

**审核**: _________________ **日期**: _________________ 